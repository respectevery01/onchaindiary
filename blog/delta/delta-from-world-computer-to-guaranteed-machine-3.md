# 从世界计算机到担保机：第三部分

## 如何构建区块链无法承载的应用

*这是关于为何我们需要域名系统的三部分系列文章的第三部分。*

- *第一部分：开发者视角下区块链并非适用工具的场景分析。*

- *第二部分：区分“计算机”与“担保机”的概念转变。*

- *第三部分：展示 “以域为载体的应用究竟是什么样”。*

在第一部分中，你作为一名业余开发者，致力于推出一个可验证的健康数据聚合器。你希望朋友和对手信任你声称的最大摄氧量及相关数据。你尝试使用区块链，却碰壁了——不是边缘情况，而是开发者基本需求：

- 持续外部数据流处理能力
- 事件驱动的实时更新
- 自主触发副作用操作（如自动发消息）
- 实时随机性生成
- 热补丁快速重新部署
- 丰富的本地开发工具链
- 实时可观测性
- 私有状态存储
- 文件系统与云突发操作（如批量导出数据）
- 时钟与时区灵活适配
- 非轻量型程序（如大型模型）运行能力

在第二部分中我们解释了原因：区块链是通过复制性、确定性执行来强制约束的担保机。可编程性并未移除壁垒，而是将其编码固化。在链上追求“更好的计算机”是错误的方向。链的价值在于它们能阻止什么，而非计算什么。

借助差异验证，无需依赖性能低下的计算机即可实现可验证性。将应用保留在普通基础设施上，仅导出他人必须信任的声明——这些声明遵循可被验证的明确规则。

### 构建可验证的健身数据聚合应用

无需在链上重构整个应用，只需为现有应用 “附加一个域”—— 由 “轻量化适配器” 与 “一组域内法则” 构成，再将声明发布到遵循 “全局法则” 的共享状态网络（即 Delta）中即可。具体到健身应用，实现步骤如下：

**健身应用示例**

1. （选择共享状态）首先确定应用的哪些状态部分需保留在 delta 上。此例中，仅关注最大摄氧量估算值，因此只需设计一个轻量适配器，按特定频率将此数据发布至 delta。
2. （设定保障条件）最大摄氧量估算值将由应用内事件驱动，例如基于当日心率及活动数据等因素的每日估算。您编写 Rust 程序来证明该估算基于已验证数据及认可公式。
3. （发布）将带有指定保证的域部署到 delta；有效性现在将自动检查。

就这样。您的应用保留其流、模型、套接字、文件、重新部署和监控功能。只有狭窄且明确的担保层会进入网络。

> *原则：让应用在适宜的环境中运行。仅发布他人必须能够验证的内容。*

请注意，一个更复杂的系统可能会共享多种类型的数据，这些数据具有不同的事件触发器（例如基于用户交易），并编写各种本地法律以提供多种保障。在许多情况下，适配器不仅会从 delta 读取数据，还会向其写入数据，而我们的健身应用仅执行后者。

### 哪些变了，哪些没变？

| 能力                 | 应用的实际使用场景                                           | 接入 Delta 后状态                                            |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 持续外部数据流       | 可穿戴设备每几秒向事件循环传输一次心率数据包                 | 无变化。数据流仍驱动应用运行，仅将 “汇总后的声明”（如每日最大摄氧量）对外发布 |
| 事件驱动更新         | 每收到新数据包，可更新最大摄氧量或触发 “休息提醒”            | 无需将每一次微小更新都上传至 Delta，仅需发布 “已确认的每日数据声明” |
| 自主副作用操作       | 达到阈值后，机器人自动发送 Slack 消息、同步至 Google Fit、写入私有数据库 | 所有操作均在 Delta 之外完成，无需依赖任何特殊中间件          |
| 实时随机性           | 夜间超参数搜索通过`numpy.random.uniform`随机选择新模型参数   | 保留该能力。若需增强可信度，可在域内法则中引用 “已签名的随机信标”（如[random.org](https://random.org/)签名的随机源） |
| 热补丁快速重新部署   | 修改公式后，执行`git push`并重启虚拟服务器（VPS）            | 应用核心逻辑的更新仍在 Delta 之外完成，流程与之前完全一致    |
| 丰富本地开发工具链   | 用 Jupyter 笔记本、TensorBoard、实时 Python 调试器动态优化模型 | 所有工具均可按原有方式使用，无任何限制                       |
| 实时可观测性         | Prometheus 统计数据包丢失率，Grafana 实时绘制心率变异性（HRV）图表 | 无需依赖区块链索引器等中间件，仍可直接使用 Prometheus 与 Grafana |
| 私有状态存储         | 内存环形缓冲区存储最近 5000 个心跳间隔数据，支持毫秒级推理   | 该状态仍保持私有，无需上传至 Delta                           |
| 文件系统与云突发操作 | 将一个月的运动数据批量导出至 S3、补全分析数据、删除临时文件 —— 均为常规操作 | 所有操作均在 Delta 之外完成，不受 Delta 约束                 |
| 时钟与时区灵活适配   | 调用`datetime.now()`获取实时时间，将训练计划与日落时间或时差调整对齐 | 无任何问题，仍可自由使用实时时间                             |
| 非轻量型程序规模     | 模型与依赖库体积庞大（以 MB/GB 为单位）                      | 无影响。Delta 的成本仅与 “域内法则的复杂度” 相关，与应用本身的规模无关 |

### 结论：可验证系统的未来在于 “做减法”

科技界大多聚焦于扩张，致力于实现新功能。像 Lovable 这样的生成式 AI 公司每天都会在我们的信息流中展示令人惊叹的演示。但可验证系统与 AI 不同，它们关乎稀缺性。讽刺的是，遵循科技界的范例，试图为我们的区块链注入丰富性，反而让我们固步自封。

可验证计算的目的在于约束。试图让区块链像完整计算机一样运行，会将普通软件拒之门外。其优势在于可验证性，而非吞吐量或虚拟机特性。域将范围缩小至他人依赖的规则，并将这些规则发布到共享状态中。其余一切仍保持为普通程序。

你一直都能编写定义和操作资产的软件。借助域和增量，现在你可以在开放的互联网上可信地实现这一点，而无需将你的应用束缚于条条框框。

## 附录：健身数据聚合应用域内法则示例规范

### 域内法则：`vo2_daily_v1`

#### 1. 输入

- 设备数据流：来自 “已注册设备 ID” 的 “已签名心率数据包 + 活动数据包”；
- 覆盖窗口： `[00:00, 24:00)` 本地时间，最多存在 N 个短间隙（每个≤G 秒）。
- 模型标准：`F_v`。

#### 2. 前置条件

- 设备公钥（`device.pubkey`）已与用户（`user`）绑定；
- 数据包时间戳需满足 “单调递增”，且落在 “日期 D 至 D+1 天” 的区间内（`[D, D+1day)`）；
- 所有用于计算的数据包签名均有效。

#### 3. 不变条件

- 对于某个特定的 `F_v` ， `VO2_D = F_v(packets, params)` 成立。

#### 4. 后置条件

- `10 ≤ VO2_D ≤ 90；
- 输出需包含 `(user, date)`。