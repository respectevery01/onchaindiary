
# Reencryption
重加密允许用户访问自己的私有数据，而无需将其暴露给任何其他人。

前一页描述的密文解密由链上智能合约触发，并将公开底层明文。对于某些用例，例如访问您的私有机密代币余额，公开解密是不可取的。

当用户希望访问自己的私有数据而不向任何第三方透露时，重加密便发挥作用。

## 工作原理
重加密的核心思想是用户端生成一对临时的公私钥。用户随后请求协验证器解密链上Handles，并立即使用用户生成的公钥对明文进行重加密。这样，只有用户才能使用临时私钥解密重新加密后的密文。

重加密流程的序列图可在“[解密机制](https://docs.inco.org/architecture/decryption-mechanisms#re-encryption-view)”页面查看。

## 访问控制
在重加密流程中，访问控制尤为重要。重加密请求仅在满足以下两个条件时才有效：
- 请求重新加密的用户必须拥有该Handles的[访问权限](access-control)。这种链上验证机制防止他人查看您的私人数据，反之亦然。
- 请求重加密的用户必须使用能够访问该Handles的同一地址，对其生成的临时公钥签署一条 EIP-712 消息。这确保了确实是用户请求向该临时公钥进行重加密，而非恶意行为者。

## 请求重加密
重加密无需任何链上交易。在合约端，我们仅要求Handles是公开可读的。例如，对于机密代币合约，用户地址到机密余额的映射可以设置为公开。

一旦在客户端检索到需要重加密的Handles，我们可以使用 [JS SDK](https://docs.inco.org/js-sdk/existing-project#3-request-a-reencryption) 的`requestReencryption`功能来请求重加密。SDK 将执行所有底层步骤，如生成临时密钥对并签署 EIP-712 消息，并返回明文值。